/**
 * EncryptionService - AES Encryption/Decryption with Diffie-Hellman Shared Secret
 * 
 * This service handles AES encryption and decryption of messages using the shared
 * secret generated by the AlbertCrypto Diffie-Hellman key exchange.
 */

import CryptoJS from 'crypto-js';

export interface EncryptedMessage {
  ciphertext: string;
  iv: string;
  timestamp: number;
  messageId: string;
}

export interface DecryptedMessage {
  plaintext: string;
  timestamp: number;
  messageId: string;
  isValid: boolean;
}

export class EncryptionService {
  private sharedSecret: string | null = null;
  private encryptionKey: CryptoJS.lib.WordArray | null = null;

  /**
   * Initialize the encryption service with a shared secret from Diffie-Hellman
   */
  public setSharedSecret(sharedSecret: string): void {
    this.sharedSecret = sharedSecret;
    // Derive encryption key from shared secret using PBKDF2
    this.encryptionKey = CryptoJS.PBKDF2(sharedSecret, 'albert-crypto-salt', {
      keySize: 256 / 32,
      iterations: 100000
    });
  }

  /**
   * Check if encryption is ready (shared secret is set)
   */
  public isReady(): boolean {
    return this.sharedSecret !== null && this.encryptionKey !== null;
  }

  /**
   * Encrypt a plaintext message using AES-256-CBC
   * Returns an encrypted message object with IV and metadata
   */
  public encryptMessage(plaintext: string): EncryptedMessage {
    if (!this.isReady()) {
      throw new Error('Encryption service not initialized. Set shared secret first.');
    }

    // Generate random IV for this message
    const iv = CryptoJS.lib.WordArray.random(16);
    
    // Generate unique message ID
    const messageId = this.generateMessageId();
    
    // Create message payload with metadata
    const messagePayload = {
      content: plaintext,
      timestamp: Date.now(),
      messageId
    };

    // Encrypt the message payload
    const encrypted = CryptoJS.AES.encrypt(
      JSON.stringify(messagePayload),
      this.encryptionKey!,
      {
        iv: iv,
        mode: CryptoJS.mode.CBC,
        padding: CryptoJS.pad.Pkcs7
      }
    );

    return {
      ciphertext: encrypted.toString(),
      iv: iv.toString(CryptoJS.enc.Base64),
      timestamp: messagePayload.timestamp,
      messageId
    };
  }

  /**
   * Decrypt an encrypted message using AES-256-CBC
   * Returns the decrypted message with validation status
   */
  public decryptMessage(encryptedMessage: EncryptedMessage): DecryptedMessage {
    if (!this.isReady()) {
      throw new Error('Encryption service not initialized. Set shared secret first.');
    }

    try {
      // Convert IV from base64 back to WordArray
      const iv = CryptoJS.enc.Base64.parse(encryptedMessage.iv);

      // Decrypt the message
      const decrypted = CryptoJS.AES.decrypt(
        encryptedMessage.ciphertext,
        this.encryptionKey!,
        {
          iv: iv,
          mode: CryptoJS.mode.CBC,
          padding: CryptoJS.pad.Pkcs7
        }
      );

      // Convert decrypted data to string
      const decryptedString = decrypted.toString(CryptoJS.enc.Utf8);
      
      if (!decryptedString) {
        throw new Error('Failed to decrypt message - invalid key or corrupted data');
      }

      // Parse the message payload
      const messagePayload = JSON.parse(decryptedString);

      // Validate message structure
      if (!messagePayload.content || !messagePayload.timestamp || !messagePayload.messageId) {
        throw new Error('Invalid message structure');
      }

      // Verify message ID matches
      if (messagePayload.messageId !== encryptedMessage.messageId) {
        throw new Error('Message ID mismatch - possible tampering detected');
      }

      return {
        plaintext: messagePayload.content,
        timestamp: messagePayload.timestamp,
        messageId: messagePayload.messageId,
        isValid: true
      };

    } catch (error) {
      console.error('Decryption failed:', error);
      return {
        plaintext: '[DECRYPTION FAILED]',
        timestamp: encryptedMessage.timestamp,
        messageId: encryptedMessage.messageId,
        isValid: false
      };
    }
  }

  /**
   * Generate a unique message ID
   */
  private generateMessageId(): string {
    const timestamp = Date.now();
    const random = Math.random().toString(36).substring(2, 15);
    return `msg_${timestamp}_${random}`;
  }

  /**
   * Get encryption status and information
   */
  public getEncryptionInfo() {
    return {
      isReady: this.isReady(),
      hasSharedSecret: this.sharedSecret !== null,
      algorithm: 'AES-256-CBC',
      keyDerivation: 'PBKDF2',
      iterations: 100000
    };
  }

  /**
   * Clear the shared secret and encryption key (for security)
   */
  public clearKeys(): void {
    this.sharedSecret = null;
    this.encryptionKey = null;
  }

  /**
   * Test encryption/decryption with a sample message
   */
  public testEncryption(): boolean {
    if (!this.isReady()) {
      return false;
    }

    try {
      const testMessage = 'Hello, encrypted world!';
      const encrypted = this.encryptMessage(testMessage);
      const decrypted = this.decryptMessage(encrypted);
      
      return decrypted.isValid && decrypted.plaintext === testMessage;
    } catch {
      return false;
    }
  }
}

/**
 * Utility functions for message validation and security
 */
export class MessageSecurity {
  /**
   * Validate message timestamp to prevent replay attacks
   */
  public static isRecentMessage(timestamp: number, maxAgeMs: number = 300000): boolean {
    const now = Date.now();
    const age = now - timestamp;
    return age >= 0 && age <= maxAgeMs;
  }

  /**
   * Generate a fingerprint for message integrity checking
   */
  public static generateMessageFingerprint(message: EncryptedMessage): string {
    const data = `${message.ciphertext}${message.iv}${message.messageId}${message.timestamp}`;
    return CryptoJS.SHA256(data).toString(CryptoJS.enc.Hex).substring(0, 16);
  }

  /**
   * Verify message fingerprint
   */
  public static verifyMessageFingerprint(message: EncryptedMessage, fingerprint: string): boolean {
    return this.generateMessageFingerprint(message) === fingerprint;
  }
}